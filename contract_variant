// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title Laterally Integrated Network Enterprise (L.I.N.E.)
 * @dev A Decentralized Cooperative Enterprise with:
 * - Dynamic ownership based on continuous participation
 * - Value decay for inactive members
 * - Automatic profit redistribution
 */
contract LINEProtocol {
    // Struct to track member activity and ownership
    struct Member {
        uint256 contributionScore; // Dynamic ownership units
        uint256 lastActivity;      // Timestamp of last participation
        uint256 claimedRewards;    // Lifetime rewards claimed
        bool exists;
    }

    // Protocol Parameters
    uint256 public constant BASE_GROWTH = 4;    // 4% annual baseline growth
    uint256 public constant DECAY_RATE = 10;    // 10% annual decay if inactive
    uint256 public constant ACTIVITY_WINDOW = 90 days; // Must participate quarterly
    
    // State
    mapping(address => Member) public members;
    address[] public memberList;
    uint256 public totalValueUnits; // Total ownership units in circulation
    
    // Events
    event Participation(address indexed member, uint256 valueAdded);
    event OwnershipAdjusted(address indexed member, uint256 newScore);
    event RewardDistributed(address indexed member, uint256 amount);

    // Core Participation Function
    function participate(uint256 valueContributed) external payable {
        // Initialize new members
        if (!members[msg.sender].exists) {
            members[msg.sender] = Member(0, block.timestamp, 0, true);
            memberList.push(msg.sender);
        }
        
        Member storage m = members[msg.sender];
        
        // Apply decay if inactive
        if (block.timestamp > m.lastActivity + ACTIVITY_WINDOW) {
            uint256 decayPeriods = (block.timestamp - m.lastActivity) / ACTIVITY_WINDOW;
            uint256 decayFactor = 10**18;
            
            for (uint i = 0; i < decayPeriods; i++) {
                decayFactor = decayFactor * (100 - DECAY_RATE) / 100;
            }
            
            m.contributionScore = m.contributionScore * decayFactor / 10**18;
        }
        
        // Add new contribution (1:1 minting for active participants)
        uint256 addedUnits = valueContributed + msg.value;
        m.contributionScore += addedUnits;
        totalValueUnits += addedUnits;
        
        // Update activity tracker
        m.lastActivity = block.timestamp;
        
        emit Participation(msg.sender, addedUnits);
    }

    // Automatic Reward Distribution
    function distributeRewards() external {
        uint256 rewardPool = address(this).balance;
        require(rewardPool > 0, "No rewards to distribute");
        
        // Apply baseline growth (4% annualized)
        uint256 growthUnits = totalValueUnits * BASE_GROWTH / 100 / (365 days / ACTIVITY_WINDOW);
        totalValueUnits += growthUnits;
        
        // Distribute rewards proportionally
        for (uint i = 0; i < memberList.length; i++) {
            address member = memberList[i];
            Member storage m = members[member];
            
            if (m.contributionScore > 0) {
                uint256 share = (m.contributionScore * rewardPool) / totalValueUnits;
                
                if (share > 0) {
                    payable(member).transfer(share);
                    m.claimedRewards += share;
                    emit RewardDistributed(member, share);
                }
            }
        }
    }

    // Value Decay Mechanism (Callable by anyone for inactive members)
    function applyDecay(address member) external {
        Member storage m = members[member];
        require(block.timestamp > m.lastActivity + ACTIVITY_WINDOW, "Member still active");
        
        uint256 decayedUnits = m.contributionScore * DECAY_RATE / 100;
        m.contributionScore -= decayedUnits;
        totalValueUnits -= decayedUnits;
        
        emit OwnershipAdjusted(member, m.contributionScore);
    }
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract OriginalStaking {
    // State variables
    mapping(address => uint256) public balances;
    address[] public stakers;
    uint256 public totalStaked;
    
    // Events
    event Staked(address indexed user, uint256 amount);
    event RewardDistributed(address indexed user, uint256 amount);

    // Stake ETH (automatically adds to stakers list)
    function stake() external payable {
        require(msg.value > 0, "Cannot stake 0 ETH");
        
        if (balances[msg.sender] == 0) {
            stakers.push(msg.sender);
        }
        
        balances[msg.sender] += msg.value;
        totalStaked += msg.value;
        emit Staked(msg.sender, msg.value);
    }

    // Distribute rewards to all stakers (gas-intensive)
    function distributeRewards() external {
        uint256 rewardPool = address(this).balance - totalStaked;
        require(rewardPool > 0, "No rewards available");
        
        for (uint256 i = 0; i < stakers.length; i++) {
            address user = stakers[i];
            uint256 share = (balances[user] * rewardPool) / totalStaked;
            
            if (share > 0) {
                payable(user).transfer(share);
                emit RewardDistributed(user, share);
            }
        }
    }

    // Emergency withdraw (no rewards)
    function withdraw() external {
        uint256 amount = balances[msg.sender];
        require(amount > 0, "No balance to withdraw");
        
        balances[msg.sender] = 0;
        totalStaked -= amount;
        payable(msg.sender).transfer(amount);
    }
}

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract CooperativeOwnership {
    // Struct to track contributor information
    struct Contributor {
        uint256 totalContributed;  // Total ETH contributed by this address
        uint256 lastUpdated;      // Timestamp of last contribution/growth application
        bool exists;              // Flag indicating if this contributor exists
    }

    // Storage mappings
   mapping(address => Contributor) public contributors;  // Contributor data by address
   address[] public contributorList;                    // List of all contributor addresses

    // Growth parameters (replaces decay parameters)
   uint256 public totalContributions = 0;       // Total ETH contributed system-wide
   uint256 public growthRate = 4;               // 4% annual growth (fixed-point)
   uint256 public growthInterval = 365 days;    // Time between growth applications
   uint256 public lastGrowthTimestamp;          // Last time growth was applied globally

    // Events
   event ContributionReceived(address indexed user, uint256 amount);
   event ProfitsDistributed(uint256 totalAmount);
   event GrowthApplied(uint256 newTotal);

    // Modifier to check if contributor exists
   modifier onlyExisting(address user) {
        require(contributors[user].exists, "Contributor not found");
        _;
    }

    // Initialize last growth timestamp to contract creation
   constructor() {
     lastGrowthTimestamp = block.timestamp;
    }

    // ========================
    // Core Growth Functionality
    // ========================

    // Applies compound growth to the total contributions
  function _applyGrowth() internal {
        uint256 elapsed = block.timestamp - lastGrowthTimestamp;
        
        // Only proceed if full growth interval has passed
   if (elapsed >= growthInterval) {
            uint256 periods = elapsed / growthInterval;
            
            // Calculate growth factor (1.04^periods)
   uint256 growthFactor = 10**18; // 1.0 in fixed-point
            for (uint256 i = 0; i < periods; i++) {
                growthFactor = growthFactor * (100 + growthRate) / 100;
            }
            
            // Apply growth to total contributions
   uint256 newTotal = (totalContributions * growthFactor) / 10**18;
            uint256 growthAmount = newTotal - totalContributions;
            
   totalContributions = newTotal;
   lastGrowthTimestamp += periods * growthInterval;
            
   emit GrowthApplied(totalContributions);
        }
    }

    // Applies growth to an individual contributor's balance
   function _applyIndividualGrowth(address user) internal onlyExisting(user) {
        Contributor storage c = contributors[user];
        uint256 elapsed = block.timestamp - c.lastUpdated;
        
   if (elapsed >= growthInterval) {
            uint256 periods = elapsed / growthInterval;
            uint256 growthFactor = 10**18;
            
   for (uint256 i = 0; i < periods; i++) {
                growthFactor = growthFactor * (100 + growthRate) / 100;
            }
            
   uint256 newBalance = (c.totalContributed * growthFactor) / 10**18;
   uint256 growthAmount = newBalance - c.totalContributed;
            
   c.totalContributed = newBalance;
    c.lastUpdated += periods * growthInterval;
        }
    }

    // ===================
    // User-Facing Functions
    // ===================

    // Record a new contribution
  function contribute() external payable {
        require(msg.value > 0, "Contribution must be positive");
        
        // Initialize new contributor if needed
  if (!contributors[msg.sender].exists) {
            contributors[msg.sender] = Contributor(0, block.timestamp, true);
            contributorList.push(msg.sender);
        }
        
        // Apply growth before updating balances
   _applyGrowth();
   _applyIndividualGrowth(msg.sender);
       
        // Update balances
   contributors[msg.sender].totalContributed += msg.value;
   contributors[msg.sender].lastUpdated = block.timestamp;
   totalContributions += msg.value;
        
   emit ContributionReceived(msg.sender, msg.value);
    }

    // View ownership percentage (in 1e18 fixed-point)
   function getShare(address user) public view returns (uint256) {
        if (totalContributions == 0) return 0;
        return (contributors[user].totalContributed * 1e18) / totalContributions;
    }

    // Distribute contract balance as profits
   function distributeProfits() external {
        uint256 balance = address(this).balance;
        require(balance > 0, "No balance to distribute");
        
        // Apply growth to all before distribution
   _applyGrowth();
   for (uint256 i = 0; i < contributorList.length; i++) {
            _applyIndividualGrowth(contributorList[i]);
        }
        
        // Distribute according to shares
   for (uint256 i = 0; i < contributorList.length; i++) {
            address user = contributorList[i];
            uint256 share = getShare(user);
            uint256 payout = (share * balance) / 1e18;
            
   if (payout > 0) {
                payable(user).transfer(payout);
            }
        }
        
   emit ProfitsDistributed(balance);
    }

    // Manual trigger for growth application
   function applyGrowth() external {
        _applyGrowth();
        for (uint256 i = 0; i < contributorList.length; i++) {
            _applyIndividualGrowth(contributorList[i]);
        }
    }

    // Fallback function to accept ETH
   receive() external payable {
        contribute();
    }
}


// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract CooperativeOwnership {
    // Struct now tracks last activity timestamp separately
    struct Contributor {
        uint256 totalContributed;
        uint256 lastGrowthApplied; // Tracks last growth application
        uint256 lastActivity;      // Tracks last contribution
        bool exists;
    }

    // Growth parameters with activity requirements
    uint256 public growthRate = 4;            // 4% annual growth
    uint256 public growthInterval = 365 days;
    uint256 public maxInactivity = 180 days;  // 6 months without activity loses growth

    // Modified growth application
    function _applyConditionalGrowth(address user) internal {
        Contributor storage c = contributors[user];
        
        // Check if user has been active recently
        bool isActive = (block.timestamp - c.lastActivity) <= maxInactivity;
        
        if (isActive && block.timestamp >= c.lastGrowthApplied + growthInterval) {
            uint256 periods = (block.timestamp - c.lastGrowthApplied) / growthInterval;
            uint256 growthAmount = (c.totalContributed * growthRate * periods) / 100;
            
            c.totalContributed += growthAmount;
            c.lastGrowthApplied = block.timestamp;
        }
    }

    // Updated contribute function
    function contribute() external payable {
        require(msg.value > 0, "Contribution must be positive");
        
        if (!contributors[msg.sender].exists) {
            contributors[msg.sender] = Contributor(
                msg.value,
                block.timestamp,
                block.timestamp,
                true
            );
            contributorList.push(msg.sender);
        } else {
            _applyConditionalGrowth(msg.sender);
            contributors[msg.sender].totalContributed += msg.value;
            contributors[msg.sender].lastActivity = block.timestamp;
        }
        
        totalContributions += msg.value;
        emit ContributionReceived(msg.sender, msg.value);
    }
}
